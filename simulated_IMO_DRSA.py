'''
How to use this code...

1. set model pars: instNum, oosT, T and k
2. set simulated IMO-DRSA pars: v0, numRuns, DT_size, gamma
3. set intrLvl = 1 and run this code twice as follows:
	3.1 the first run generates S0.txt for all executions and DM_types 
	3.2 the second run generates data_table1 from S0.txt for all executions and DM_types
4. use jMAF to generate rules for the data_table(intrLvl)
5. intrLvl += 1
6. run the code to generate S(intrLvl-1).txt after sampling a rule from the rule set induced using 
	data_table(intrLvl-1), and using it as a constraint for nsga2
7. run the code again to generate data_table(intrLvl)
8. run the analysis explore_results_simulated_IMO_DRSA.py
8. if intrLvl <= max interactions, go back to step 4, otherwise, the procedure is terminated


'''

'''
Next:

1. check and test data_tables.py
'''

from data.DBInstances import Instance
from results.write_results import *
from samples.data_tables import *
#from get_solution import get_solution
from MOGAs.get_portfolio import get_solution_approx
#from result_analysis.read_cplex_result_file import get_f_val
from MOGAs.get_CCEF import *

# model and ga parameters
instNum = 5
k = 10 # select cardinalities
oosT = 50 ## out-of-sample period
T = 290 - oosT

# simulated IMO-DRSA paramaters
intrLvl = 3 # interaction level
DM_type = 'risk-prone' # or risk-averse
v0 = 50
numRuns = 30 # number of S0.txt generated 
DT_size = 3
# 0.05 and 0.35
gamma = 0.05 # proportion of non-dominated feasible solutions generated by the rule-imposed constraint 

# 1. Read the data 
thisInstance = Instance(instNum, 'beasley')

print("set the optimization problem for indtrack" + str(instNum) + "\n") 
print("model: cardinality constrained bi-objective mean-variance")
print("interaction level: " + str(intrLvl))


if intrLvl == 1: # get the initial set of solutions S^0 or data_table1

	for exc in range(1,numRuns+1):

		# Write the initial frontier
		filepath = "samples/indtrack" + str(instNum) + "/risk-averse/exec" + str(exc) + "/"
		try: # try to read SO.txt and generate data table
			filehandle = open(filepath + "S0.txt", 'r')
			print(filepath + " has already been computed")
			filehandle.close()
			# generate data_table1
			write_init_datatable(thisInstance.returns_i, T, instNum, exc, DT_size, k) 

		except FileNotFoundError: # generate S0.txt
			CCEF, R = compute_CCEF(thisInstance.returns_i, k, T, instNum, v0)
			#print(CCEF)
			write_initial_CCEF(instNum, R, exc) 

else: # get data_table(intrLvl) or S(intrLvl-1).txt

	for exc in range(1,numRuns+1):
		# try to read S(intrLvl-1).txt and generate data table
		filepath = "samples/indtrack" + str(instNum) + "/" + str(DM_type) + "/exec" + str(exc) + "/S" + str(intrLvl-1) + ".txt"
		try: 
			filehandle = open(filepath, 'r')
			print(filepath + " has already been computed") 
			filehandle.close()
			#generate data_table(intrLvl)
			write_datatable(filepath, thisInstance.returns_i, T, instNum, exc, DT_size, DM_type, intrLvl, k) 

		except FileNotFoundError: # generate S(intrLvl-1).txt using the rule
			print("generating S" + str(intrLvl-1) + ".txt")
			filepath_init_sol = "samples/indtrack" + str(instNum) + "/" + str(DM_type) + "/exec" + str(exc) + "/S" + str(intrLvl-2) + ".txt"
			filehandle_init = open(filepath_init_sol, 'r')
			rule = sample_rule(instNum, DM_type, intrLvl, exc) 
			# generate S(intrLvl-1).txt
			CCEF_rule, R_rule = compute_CCEF_rule_guided(filehandle_init, rule, gamma, thisInstance.returns_i, k, T, instNum)
			write_CCEF(instNum, R_rule, exc, intrLvl, DM_type)











