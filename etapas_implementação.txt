0. (Feito) Copiar o código base do GQ para esta pasta
1. (Feito) Baixar todos os arquivos portx e portefx -> http://people.brunel.ac.uk/~mastjjb/jeb/orlib/portinfo.html
	1.1 (Feito) colocar os arquivos idxtrack de beasley na pasta
2. (Feito) Computar matriz de correlação e verificar se bate com as de Beasley (291 amostras)
3. (Feito) Computar retorno e verificar se bate com os de Beasley (291 amostras)
4. (Feito) Em seguida, computar UEF e comparar com a de Beasley
Gerar novo arquivo get_UEF onde o cplex obtem 2000 pontos (ver chang2000)
(falar no paper que a validação do modelo e do MOGA foram na abordagem de chang2000 com os dados de beasley)

* A partir dos passos 2,3 e 4 validamos os algoritmos para o cálculo da variancia, retorno
  e UEF para qualquer amostra in-sample. Portanto, já temos o modelo implementado e validado.

NSGA-II
(feito) 1. Implementar NSGA-II seguindo mishra2014 (constraint handling) ou anagnostopoulos
	mudar inicialização
	(feito)* mating selection: binary tounament selection (anagnostopoulos)
	(feito)* crossover: uniform -> bin string
	(feito)* mutation: gaussian (real string) and santanna mutation (bin string) -> anagnostopoulos

Rodar NSGA-II com K = 10 por 1hr para as instâncias 2,3,4,5,6
	1. anotar tempo computacional
	2. anotar solução

DRSA
1. Rodar NSGA2
2. Mostrar desenho ilustrativo de como são feitas as simulações (desenhar fronteira e duas retas separando 
regiões de densidade para cada investidor - risk-averse, neutral and risk-prone)
3. Gerar exemplos de decisão simulados (sample de classes binárias ponderada) para cada tipo de decisor 
4. Montar mecanismo para gerar output das etapas de interação com o investidor simulado
5. Gerar regras e rodar o algoritmo baseando-se nestas regras, iniciando o nsga2 a partir da fronteira dada para o DRSA

Sempre salvar tempo computacional do nsga2 depois de cada interação com o decisor simulado



